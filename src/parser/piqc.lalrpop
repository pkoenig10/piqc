use ast::*;

grammar;

Type: Type = {
    "int" => Type::Int,
    "float" => Type::Float,
    "bool" => Type::Bool,
};

Int: i32 = {
    r"\d+" => <>.parse().unwrap(),
};

Float: f32 = {
    r"\d*\.\d*" => <>.parse().unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate,
    "~" => UnaryOp::BitNot,
    "!" => UnaryOp::LogicalNot,
};

MultiplicativeOp: BinaryOp = {
    "*" => BinaryOp::Mul,
};

AdditiveOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

ShiftOp: BinaryOp = {
    "<<" => BinaryOp::Shl,
    ">>" => BinaryOp::Shr,
};

BitAndOp: BinaryOp = {
    "&" => BinaryOp::BitAnd,
};

BitXorOp: BinaryOp = {
    "^" => BinaryOp::BitXor,
};

BitOrOp: BinaryOp = {
    "|" => BinaryOp::BitOr,
};

ComparisonOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
};

LogicalAndOp: BinaryOp = {
    "&&" => BinaryOp::LogicalAnd,
};

LogicalOrOp: BinaryOp = {
    "||" => BinaryOp::LogicalOr,
};

Identifier: Identifier<'input> = {
    @L r"[A-Za-z_][0-9A-Za-z_]*" @R => Identifier::new(<>),
};

IntLiteral: IntLiteral = {
    @L Int @R => IntLiteral::new(<>),
};

FloatLiteral: FloatLiteral = {
    @L Float @R => FloatLiteral::new(<>),
};

BoolLiteral: BoolLiteral = {
    @L Bool @R => BoolLiteral::new(<>),
};

PrimaryExpr: Expr<'input> = {
    IntLiteral => Expr::IntLiteral(<>),
    FloatLiteral => Expr::FloatLiteral(<>),
    BoolLiteral => Expr::BoolLiteral(<>),
    Identifier => Expr::Identifier(<>),
    "(" <Expr> ")" => <>,
};

UnaryExpr: Expr<'input> = {
    PrimaryExpr,
    @L UnaryOp UnaryExpr @R => UnaryExpr::new(<>),
};

BinaryExpr<Op, PrevExpr>: Expr<'input> = {
    PrevExpr,
    @L BinaryExpr<Op, PrevExpr> Op PrevExpr @R => BinaryExpr::new(<>),
};

MultiplicativeExpr = BinaryExpr<MultiplicativeOp, UnaryExpr>;

AdditiveExpr = BinaryExpr<AdditiveOp, MultiplicativeExpr>;

ShiftExpr = BinaryExpr<ShiftOp, AdditiveExpr>;

BitAndExpr = BinaryExpr<BitAndOp, ShiftExpr>;

BitXorExpr = BinaryExpr<BitXorOp, BitAndExpr>;

BitOrExpr = BinaryExpr<BitOrOp, BitXorExpr>;

ComparisonExpr = BinaryExpr<ComparisonOp, BitOrExpr>;

LogicalAndExpr = BinaryExpr<LogicalAndOp, ComparisonExpr>;

LogicalOrExpr = BinaryExpr<LogicalOrOp, LogicalAndExpr>;

Expr: Expr<'input> = {
    LogicalOrExpr,
};

DeclStmt: DeclStmt<'input> = {
    <@L> <Type> <Identifier> "=" <Expr> ";" <@R> => DeclStmt::new(<>),
};

AssignStmt: AssignStmt<'input> = {
    <@L> <Identifier> "=" <Expr> ";" <@R> => AssignStmt::new(<>),
};

ReturnStmt: ReturnStmt = {
    <@L> "return" ";" <@R> => ReturnStmt::new(<>),
};

BlockStmt: BlockStmt<'input> = {
    <@L> "{" <Stmt*> "}" <@R> => BlockStmt::new(<>),
};

Stmt: Stmt<'input> = {
    DeclStmt => Stmt::DeclStmt(<>),
    AssignStmt => Stmt::AssignStmt(<>),
    ReturnStmt => Stmt::ReturnStmt(<>),
    BlockStmt => Stmt::BlockStmt(<>),
};

Param: Param<'input> = {
    @L Type Identifier @R => Param::new(<>),
};

Params: Vec<Param<'input>> = {
    Param => vec![<>],
    <params: Params> "," <param: Param> => {
        let mut params = params;
        params.push(param);
        params
    },
};

Func: Func<'input> = {
    <@L> "fn" <Identifier> "(" <Params?> ")" <BlockStmt> <@R> => Func::new(<>),
};

pub Prog: Prog<'input> = {
    <Func*> => Prog::new(<>),
};
