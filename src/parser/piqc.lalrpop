#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

use ast::*;

grammar;

Type: Type = {
    "int" => Int,
    "float" => Float,
    "bool" => Bool,
};

Int: i32 = {
    r"\d+" => <>.parse().unwrap(),
};

Float: f32 = {
    r"\d*\.\d*" => <>.parse().unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

UnaryOp: UnaryOp = {
    "-" => Negate,
    "~" => BitNot,
    "!" => LogicalNot,
};

MultiplicativeOp: BinaryOp = {
    "*" => Mul,
};

AdditiveOp: BinaryOp = {
    "+" => Add,
    "-" => Sub,
};

ShiftOp: BinaryOp = {
    "<<" => Shl,
    ">>" => Shr,
};

BitAndOp: BinaryOp = {
    "&" => BitAnd,
};

BitXorOp: BinaryOp = {
    "^" => BitXor,
};

BitOrOp: BinaryOp = {
    "|" => BitOr,
};

OrderOp: BinaryOp = {
    "<?" => Min,
    ">?" => Max,
};

ComparisonOp: BinaryOp = {
    "==" => Eq,
    "!=" => Ne,
    "<" => Lt,
    ">" => Gt,
    "<=" => Le,
    ">=" => Ge,
};

LogicalAndOp: BinaryOp = {
    "&&" => LogicalAnd,
};

LogicalOrOp: BinaryOp = {
    "||" => LogicalOr,
};

IntLiteral: IntLiteral = {
    @L Int @R => IntLiteral::new(<>),
};

FloatLiteral: FloatLiteral = {
    @L Float @R => FloatLiteral::new(<>),
};

BoolLiteral: BoolLiteral = {
    @L Bool @R => BoolLiteral::new(<>),
};

Index: Index = {
    <@L> "@index" <@R> => Index::new(<>),
};

Count: Count = {
    <@L> "@count" <@R> => Count::new(<>),
};

Identifier: Identifier<'input> = {
    @L r"[A-Za-z_][0-9A-Za-z_]*" @R => Identifier::new(<>),
};

PrimaryExpr: Expr<'input> = {
    IntLiteral => Expr::IntLiteral(<>),
    FloatLiteral => Expr::FloatLiteral(<>),
    BoolLiteral => Expr::BoolLiteral(<>),
    Index => Expr::Index(<>),
    Count => Expr::Count(<>),
    Identifier => Expr::Identifier(<>),
    "(" <Expr> ")" => <>,
};

UnaryExpr: Expr<'input> = {
    PrimaryExpr,
    @L UnaryOp UnaryExpr @R => Expr::UnaryExpr(UnaryExpr::new(<>)),
};

BinaryExpr<Op, PrevExpr>: Expr<'input> = {
    PrevExpr,
    @L BinaryExpr<Op, PrevExpr> Op PrevExpr @R => Expr::BinaryExpr(BinaryExpr::new(<>)),
};

MultiplicativeExpr = BinaryExpr<MultiplicativeOp, UnaryExpr>;

AdditiveExpr = BinaryExpr<AdditiveOp, MultiplicativeExpr>;

ShiftExpr = BinaryExpr<ShiftOp, AdditiveExpr>;

BitAndExpr = BinaryExpr<BitAndOp, ShiftExpr>;

BitXorExpr = BinaryExpr<BitXorOp, BitAndExpr>;

BitOrExpr = BinaryExpr<BitOrOp, BitXorExpr>;

OrderExpr = BinaryExpr<OrderOp, BitOrExpr>;

ComparisonExpr = BinaryExpr<ComparisonOp, OrderExpr>;

LogicalAndExpr = BinaryExpr<LogicalAndOp, ComparisonExpr>;

LogicalOrExpr = BinaryExpr<LogicalOrOp, LogicalAndExpr>;

Expr: Expr<'input> = {
    LogicalOrExpr,
};

BlockStmt: BlockStmt<'input> = {
    <@L> "{" <Stmt*> "}" <@R> => BlockStmt::new(<>),
};

DeclStmt: DeclStmt<'input> = {
    <@L> <Type> <Identifier> "=" <Expr> ";" <@R> => DeclStmt::new(<>),
};

AssignStmt: AssignStmt<'input> = {
    <@L> <Identifier> "=" <Expr> ";" <@R> => AssignStmt::new(<>),
};

IfStmt: IfStmt<'input> = {
    <@L> "if" "(" <Expr> ")" <BlockStmt> <@R> => IfStmt::new(<>),
};

WhileStmt: WhileStmt<'input> = {
    <@L> "while" "(" <Expr> ")" <BlockStmt> <@R> => WhileStmt::new(<>),
};

ReturnStmt: ReturnStmt = {
    <@L> "return" ";" <@R> => ReturnStmt::new(<>),
};

Stmt: Stmt<'input> = {
    BlockStmt => Stmt::BlockStmt(<>),
    DeclStmt => Stmt::DeclStmt(<>),
    AssignStmt => Stmt::AssignStmt(<>),
    IfStmt => Stmt::IfStmt(<>),
    WhileStmt => Stmt::WhileStmt(<>),
    ReturnStmt => Stmt::ReturnStmt(<>),
};

Param: Param<'input> = {
    @L Type Identifier @R => Param::new(<>),
};

Params: Params<'input> = {
    <params: (<Params> ",")?> <param: Param> => {
        let mut params = params.unwrap_or_else(Params::new);
        params.push(param);
        params
    },
};

Func: Func<'input> = {
    <@L> "fn" <Identifier> "(" <Params?> ")" <BlockStmt> <@R> => Func::new(<>),
};

pub Prog: Prog<'input> = {
    Func => Prog::new(<>),
};
