use ast::expr::*;
use ast::func::*;
use ast::prog::*;
use ast::stmt::*;
use ast::type_::*;

grammar;

Type: Type = {
    "int" => Type::Int,
    "float" => Type::Float,
    "bool" => Type::Bool,
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

Identifier: Identifier = {
    r"[A-Za-z_][0-9A-Za-z_]*" => Identifier::new(<>),
};

IntLiteral: IntLiteral = {
    r"\d+" => IntLiteral::new(<>.parse().unwrap()),
};

FloatLiteral: FloatLiteral = {
    r"\d*\.\d*" => FloatLiteral::new(<>.parse().unwrap()),
};

BoolLiteral: BoolLiteral = {
    Bool => BoolLiteral::new(<>),
};

UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate,
    "~" => UnaryOp::BitNot,
    "!" => UnaryOp::LogicalNot,
};

MultiplicativeOp: BinaryOp = {
    "*" => BinaryOp::Mul,
};

AdditiveOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

ShiftOp: BinaryOp = {
    "<<" => BinaryOp::Shl,
    ">>" => BinaryOp::Shr,
};

BitAndOp: BinaryOp = {
    "&" => BinaryOp::BitAnd,
};

BitXorOp: BinaryOp = {
    "^" => BinaryOp::BitXor,
};

BitOrOp: BinaryOp = {
    "|" => BinaryOp::BitOr,
};

ComparisonOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
};

LogicalAndOp: BinaryOp = {
    "&&" => BinaryOp::LogicalAnd,
};

LogicalOrOp: BinaryOp = {
    "||" => BinaryOp::LogicalOr,
};

PrimaryExpr: Expr = {
    IntLiteral => Expr::IntLiteral(<>),
    FloatLiteral => Expr::FloatLiteral(<>),
    BoolLiteral => Expr::BoolLiteral(<>),
    Identifier => Expr::Identifier(<>),
    "(" <Expr> ")" => <>,
};

UnaryExpr: Expr = {
    PrimaryExpr,
    UnaryOp UnaryExpr => UnaryExpr::new(<>),
};

BinaryExpr<Op, Expr>: Expr = {
    Expr,
    BinaryExpr<Op, Expr> Op Expr => BinaryExpr::new(<>),
};

MultiplicativeExpr = BinaryExpr<MultiplicativeOp, UnaryExpr>;

AdditiveExpr = BinaryExpr<AdditiveOp, MultiplicativeExpr>;

ShiftExpr = BinaryExpr<ShiftOp, AdditiveExpr>;

BitAndExpr = BinaryExpr<BitAndOp, ShiftExpr>;

BitXorExpr = BinaryExpr<BitXorOp, BitAndExpr>;

BitOrExpr = BinaryExpr<BitOrOp, BitXorExpr>;

ComparisonExpr = BinaryExpr<ComparisonOp, BitOrExpr>;

LogicalAndExpr = BinaryExpr<LogicalAndOp, ComparisonExpr>;

LogicalOrExpr = BinaryExpr<LogicalOrOp, LogicalAndExpr>;

Expr: Expr = {
    LogicalOrExpr,
};

DeclStmt: DeclStmt = {
    <Type> <Identifier> "=" <Expr> ";" => DeclStmt::new(<>),
};

AssignStmt: AssignStmt = {
    <Identifier> "=" <Expr> ";" => AssignStmt::new(<>),
};

ReturnStmt: ReturnStmt = {
    "return" ";" => ReturnStmt::new(),
};

BlockStmt: BlockStmt = {
    "{" <Stmt*> "}" => BlockStmt::new(<>),
};

Stmt: Stmt = {
    DeclStmt => Stmt::DeclStmt(<>),
    AssignStmt => Stmt::AssignStmt(<>),
    ReturnStmt => Stmt::ReturnStmt(<>),
    BlockStmt => Stmt::BlockStmt(<>),
};

Param: Param = {
    <Type> <Identifier> => Param::new(<>),
};

Params_: Vec<Param> = {
    Param => vec![<>],
    <params: Params_> "," <param: Param> => {
        let mut params = params;
        params.push(param);
        params
    },
};

Params: Params = {
    <Params_?> => Params::new(<>.unwrap_or(vec![])),
};

Func: Func = {
    "fn" <Identifier> "(" <Params> ")" <BlockStmt> => Func::new(<>),
};

pub Prog: Prog = {
    <Func*> => Prog::new(<>),
};
