use ast::*;

grammar;

Type: Type = {
    "int" => Type::Int,
    "float" => Type::Float,
    "bool" => Type::Bool,
};

Int: i32 = {
    r"\d+" => <>.parse().unwrap(),
};

Float: f32 = {
    r"\d*\.\d*" => <>.parse().unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate,
    "~" => UnaryOp::BitNot,
    "!" => UnaryOp::LogicalNot,
};

MultiplicativeOp: BinaryOp = {
    "*" => BinaryOp::Mul,
};

AdditiveOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

ShiftOp: BinaryOp = {
    "<<" => BinaryOp::Shl,
    ">>" => BinaryOp::Shr,
};

BitAndOp: BinaryOp = {
    "&" => BinaryOp::BitAnd,
};

BitXorOp: BinaryOp = {
    "^" => BinaryOp::BitXor,
};

BitOrOp: BinaryOp = {
    "|" => BinaryOp::BitOr,
};

OrderOp: BinaryOp = {
    "<?" => BinaryOp::Min,
    ">?" => BinaryOp::Max,
};

ComparisonOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
};

LogicalAndOp: BinaryOp = {
    "&&" => BinaryOp::LogicalAnd,
};

LogicalOrOp: BinaryOp = {
    "||" => BinaryOp::LogicalOr,
};

IntLiteral: IntLiteral = {
    @L Int @R => IntLiteral::new(<>),
};

FloatLiteral: FloatLiteral = {
    @L Float @R => FloatLiteral::new(<>),
};

BoolLiteral: BoolLiteral = {
    @L Bool @R => BoolLiteral::new(<>),
};

Index: Index = {
    <@L> "@index" <@R> => Index::new(<>),
};

Count: Count = {
    <@L> "@count" <@R> => Count::new(<>),
};

Identifier: Identifier<'input> = {
    @L r"[A-Za-z_][0-9A-Za-z_]*" @R => Identifier::new(<>),
};

PrimaryExpr: Expr<'input> = {
    IntLiteral => Expr::IntLiteral(<>),
    FloatLiteral => Expr::FloatLiteral(<>),
    BoolLiteral => Expr::BoolLiteral(<>),
    Index => Expr::Index(<>),
    Count => Expr::Count(<>),
    Identifier => Expr::Identifier(<>),
    "(" <Expr> ")" => <>,
};

UnaryExpr: Expr<'input> = {
    PrimaryExpr,
    @L UnaryOp UnaryExpr @R => Expr::Unary(UnaryExpr::new(<>)),
};

BinaryExpr<Op, PrevExpr>: Expr<'input> = {
    PrevExpr,
    @L BinaryExpr<Op, PrevExpr> Op PrevExpr @R => Expr::Binary(BinaryExpr::new(<>)),
};

MultiplicativeExpr = BinaryExpr<MultiplicativeOp, UnaryExpr>;

AdditiveExpr = BinaryExpr<AdditiveOp, MultiplicativeExpr>;

ShiftExpr = BinaryExpr<ShiftOp, AdditiveExpr>;

BitAndExpr = BinaryExpr<BitAndOp, ShiftExpr>;

BitXorExpr = BinaryExpr<BitXorOp, BitAndExpr>;

BitOrExpr = BinaryExpr<BitOrOp, BitXorExpr>;

OrderExpr = BinaryExpr<OrderOp, BitOrExpr>;

ComparisonExpr = BinaryExpr<ComparisonOp, OrderExpr>;

LogicalAndExpr = BinaryExpr<LogicalAndOp, ComparisonExpr>;

LogicalOrExpr = BinaryExpr<LogicalOrOp, LogicalAndExpr>;

Expr: Expr<'input> = {
    LogicalOrExpr,
};

BlockStmt: BlockStmt<'input> = {
    <@L> "{" <Stmt*> "}" <@R> => BlockStmt::new(<>),
};

DeclStmt: DeclStmt<'input> = {
    <@L> <Type> <Identifier> "=" <Expr> ";" <@R> => DeclStmt::new(<>),
};

AssignStmt: AssignStmt<'input> = {
    <@L> <Identifier> "=" <Expr> ";" <@R> => AssignStmt::new(<>),
};

IfBlock: Stmt<'input> = {
    BlockStmt => Stmt::Block(<>),
};

ElseBlock: Stmt<'input> = {
    BlockStmt => Stmt::Block(<>),
    IfStmt => Stmt::If(<>),
};

IfStmt: IfStmt<'input> = {
    <@L> "if" "(" <Expr> ")" <IfBlock> <("else" <ElseBlock>)?> <@R> => IfStmt::new(<>),
};

WhileBlock: Stmt<'input> = {
    BlockStmt => Stmt::Block(<>),
};

WhileStmt: WhileStmt<'input> = {
    <@L> "while" "(" <Expr> ")" <WhileBlock> <@R> => WhileStmt::new(<>),
};

ReturnStmt: ReturnStmt = {
    <@L> "return" ";" <@R> => ReturnStmt::new(<>),
};

Stmt: Stmt<'input> = {
    BlockStmt => Stmt::Block(<>),
    DeclStmt => Stmt::Decl(<>),
    AssignStmt => Stmt::Assign(<>),
    IfStmt => Stmt::If(<>),
    WhileStmt => Stmt::While(<>),
    ReturnStmt => Stmt::Return(<>),
};

Param: Param<'input> = {
    @L Type Identifier @R => Param::new(<>),
};

Params: Vec<Param<'input>> = {
    <params: (<Params> ",")?> <param: Param> => {
        let mut params = params.unwrap_or_else(Vec::new);
        params.push(param);
        params
    },
};

FuncBlock: Stmt<'input> = {
    BlockStmt => Stmt::Block(<>),
};

Func: Func<'input> = {
    <@L> "fn" <Identifier> "(" <Params?> ")" <FuncBlock> <@R> => Func::new(<>),
};

pub Prog: Prog<'input> = {
    @L Func @R => Prog::new(<>),
};
